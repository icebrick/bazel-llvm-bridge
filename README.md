# Bazel to the LLVM Compiler Infrastructure bridge

[Bazel](https://docs.bazel.build/versions/master/bazel-overview.html) is an open-source
build and test tool similar to Make, Maven, and Gradle. It uses a human-readable,
high-level build language. Bazel supports projects in multiple languages and builds outputs
for multiple platforms. For example, Tensorflow - end-to-end open-source platform for
machine learning - uses Bazel as the build system.

[LLVM](https://llvm.org/) is a collection of modular and reusable compiler and toolchain
technologies. The LLVM Core libraries provide a modern source- and target-independent
optimizer and code generator that makes it easy to invent a new programming language or
port an existing compiler. Also LLVM provides its own native C/C++ compiler - Clang,
debugger - LLDB, an implementation of the C++ Standard Library, and many other interesting
things. The full list of LLVM's primary sub-projects is available on the official web-site.

This project provides a bridge that let you use static libraries from a local installation
of LLVM in your projects when Bazel is used for building. Each library from LLVM/Clang
(including the special 'headers' library that provides LLVM's and Clang's headers)
is available as a `@local_llvm//:llvm_<library_name>` dependency (`@local_llvm//:llvm_headers`
for the headers library, `clang` as the prefix for Clang's libraries), where `@local_llvm`
is the name of the used `llvm_configure`
[repository rule](https://docs.bazel.build/versions/master/skylark/repository_rules.html)
and can be edited in your `WORKSPACE`. Notice that a library will bring also its dependencies
exactly how the CMake build works.

When LLVM/Clang is built on an environment that supports the
[*Z3 Solver*](https://github.com/Z3Prover/z3), the code of some LLVM and Clang libraries
is enriched by Z3 and projects dependent on the libraries must be linked against it.
To enable the linking, an environment variable is added: `Z3_INSTALL_PREFIX`.
If the environment variable is set, the Z3 library will be copied into the building
directory and a target for the Z3 Solver will be added into the `deps` attribute of the
`llvm_support` library.

Platform-provided libraries such as "ncurses", "tinfo", "pthreads" will be detected
automatically using the `*.cmake` files generated by CMake during the LLVM build process.

Notice: The minimum supported version of Bazel is
[**0.25.0**](https://github.com/bazelbuild/bazel/releases/tag/0.25.0).


### How to leverage the bridge in your project

In order to use any LLVM libraries in your targets, add the following to your
`WORKSPACE` file:

```bzl
load("@bazel_tools//tools/build_defs/repo:http.bzl", "http_archive")

http_archive(
    name = "bazel_llvm_bridge",
    sha256 = "84ec681de4fe305109623255d110a948cd5c88c45d584dac5dd9b9dc2a4fea8e",
    strip_prefix = "bazel-llvm-bridge-pre-release-10-01",
    url = "https://github.com/samolisov/bazel-llvm-bridge/archive/pre-release/10-01.zip",
)

load("@bazel_llvm_bridge//llvm:llvm_configure.bzl", "llvm_configure")

llvm_configure(name = "local_llvm")
```

Where `name` is whatever you want.

A version number is matched to the version of LLVM and can be found in the `release/<version>-<build>`
tag or `release/<version>.x` branch. For example:

```bash
$ git clone https://github.com/samolisov/bazel-llvm-bridge.git
$ git checkout release/9.x
$ git log --oneline -1
```

Shows you the latest commit in the release branch. The commit can be used as a value of the `commit`
attribute of the `git_repository` rule to checkout the compatible version of **bazel-llvm-bridge** for
the used version of **LLVM**:

```bzl
git_repository(
    name = "bazel_llvm_bridge",
    commit = "<THE LATEST COMMIT HERE>",
    remote = "https://github.com/samolisov/bazel-llvm-bridge.git",
)
```

Now the desired libraries can be added as dependencies (the `deps` attribute) to targets for
your libraries and binaries (through the `@local_llvm` repository):

```bzl
cc_binary(
    name = 'llvm_bb_counter',
    srcs = [
        "llvm/llvm_bb_counter.cc",
    ],
    deps = [
        "@local_llvm//:llvm_headers",
        "@local_llvm//:llvm_bit_reader",
    ],
    visibility = ["//visibility:private"],
)
```

### How to build the project

To build your targets, do the following:

 0. Build from sources or download from http://releases.llvm.org/download.html an
    archive with an LLVM package for your platform. The package must be unarchived
    into a local directory.

 1. Set up the `LLVM_INSTALL_PREFIX` environment variable. The variable must
    contain a path to a local LLVM installation:

    ```bash
    $ export LLVM_INSTALL_PREFIX=~/dev/llvm_master
    ```

    or, on Windows:

    ```bash
    $ set LLVM_INSTALL_PREFIX=C:\Dev\llvm_master
    ```

 2. (Optional) Set up the `Z3_INSTALL_PREFIX` environment variable. The variable must
    contain a path to a local Z3 Solver installation:

    ```bash
    $ export Z3_INSTALL_PREFIX=/usr/local
    ```

    or, on Windows:

    ```bash
    $ set Z3_INSTALL_PREFIX="C:\Program Files\z3"
    ```

 3. Run the build:

    ```bash
    $ bazel build //:llvm_bb_counter
    ```

    alternatively, the environment variables may be passed directly to the build
    command:

    ```bash
    $ bazel build --action_env LLVM_INSTALL_PREFIX=C:\Dev\llvm_master
      --action_env Z3_INSTALL_PREFIX="C:\Program Files\z3" //:clang_list_methods
    ```

### How to deal with targets

The **bazel-llvm-bridge** supports all out-of-the-box provided LLVM targets:
 * AArch64
 * AMDGPU
 * ARM
 * BPF
 * Hexagon
 * Lanai
 * Mips
 * MSP430
 * NVPTX
 * PowerPC
 * RISCV
 * Sparc
 * SystemZ
 * WebAssembly
 * X86
 * XCore

To link against a target, the user should to check whether the target is supported by the used
local installation of LLVM. A set of `if_has_<TARGET>` functions are provided by
`@local_llvm//:llvm_config.bzl` generated skylark file. Every function returns its first argument
when the target `<TARGET>` is supported, otherwise it returns the second argument. The function
is usable through the following way (see the `//:llvm_print_supported_targets` target in
the `examples/BUILD` file):

```bzl
load("@local_llvm//:llvm_config.bzl",
    "llvm_copts",
    "if_has_aarch64",
    ...
    "if_has_x86")

cc_binary(
    name = "llvm_print_supported_targets",
    srcs = [
        ...
    ],
    copts = llvm_copts()
        + if_has_aarch64(["-DLLVM_SUPPORTS_TARGET_AARCH64"])
        ...
        + if_has_x86(["-DLLVM_SUPPORTS_TARGET_X86"]),
    deps = if_has_aarch64([
        "@local_llvm//:llvm_aarch64_asm_parser",
        "@local_llvm//:llvm_aarch64_code_gen",
        "@local_llvm//:llvm_aarch64_disassembler",
    ]) +
    ...
       + if_has_x86([
        "@local_llvm//:llvm_x86_asm_parser",
        "@local_llvm//:llvm_x86_code_gen",
        "@local_llvm//:llvm_x86_disassembler",
    ])
)
```

### How to deal with Clang/LLVM shared libraries

Important note for users of the `libclang`, `libclang-cpp` and `LLVM-C` shared
libraries. There are three rules to bring these libraries from the LLVM
installation into the `bazel-bin`: `clang_copy_libclang`, `clang_copy_libclang_cpp`
and `llvm_copy_c`. Just add the targets into the `data` attribute of a rule and
they will appear in a `bazel-bin/external/<name of llvm_configure repository rule>`
directory. Then the libraries can be copied into the `bazel-bin` (see genrules
in the `examples/BUILD` file) and be used for running your applications.
